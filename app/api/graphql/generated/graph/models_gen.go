// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"fmt"
	"io"
	"gogql/app/models/dbmodels"
	"strconv"

	"github.com/gofrs/uuid"
	"github.com/volatiletech/null"
)

type BatchActionInput struct {
	ID       *null.Int64  `json:"id,omitempty"`
	Str      *null.String `json:"str,omitempty"`
	No       *null.Int64  `json:"no,omitempty"`
	DateTime *null.Time   `json:"dateTime,omitempty"`
	Bool     *null.Bool   `json:"bool,omitempty"`
}

type DepartmentsResult struct {
	Departments []dbmodels.Department `json:"departments"`
	Total       int                   `json:"total"`
}

type FileInput struct {
	Name string `json:"name"`
	URL  string `json:"url"`
}

type LoginRequest struct {
	Email *null.String `json:"email,omitempty"`
	Phone *null.String `json:"phone,omitempty"`
	Otp   *null.String `json:"otp,omitempty"`
}

type OTPRequest struct {
	Email *null.String `json:"email,omitempty"`
	Phone *null.String `json:"phone,omitempty"`
}

type OrganizationsResult struct {
	Organizations []dbmodels.Organization `json:"organizations"`
	Total         int                     `json:"total"`
}

type PageInfo struct {
	StartCursor int64 `json:"startCursor"`
	EndCursor   int64 `json:"endCursor"`
}

type RegisterOrganization struct {
	OrgName   *null.String `json:"orgName,omitempty"`
	Website   *null.String `json:"website,omitempty"`
	Logo      *FileInput   `json:"logo,omitempty"`
	Sector    *null.String `json:"sector,omitempty"`
	FirstName *null.String `json:"firstName,omitempty"`
	LastName  *null.String `json:"lastName,omitempty"`
	Email     *null.String `json:"email,omitempty"`
	Phone     *null.String `json:"phone,omitempty"`
}

type RequestToken struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type RolesResult struct {
	Roles []dbmodels.Role `json:"roles"`
	Total int             `json:"total"`
}

type SearchFilter struct {
	Search  *null.String  `json:"search,omitempty"`
	Filter  *FilterOption `json:"filter,omitempty"`
	SortBy  *SortByOption `json:"sortBy,omitempty"`
	SortDir *SortDir      `json:"sortDir,omitempty"`
	Offset  *null.Int     `json:"offset,omitempty"`
	Limit   *null.Int     `json:"limit,omitempty"`
	OrgUID  *uuid.UUID    `json:"orgUID,omitempty"`
}

type UpdateDepartment struct {
	Name   *null.String   `json:"name,omitempty"`
	OrgUID *uuid.NullUUID `json:"orgUID,omitempty"`
}

type UpdateOrganization struct {
	Name    *null.String `json:"name,omitempty"`
	Website *null.String `json:"website,omitempty"`
	Sector  *null.String `json:"sector,omitempty"`
	Logo    *FileInput   `json:"logo,omitempty"`
}

type UpdateRole struct {
	Name         *null.String   `json:"name,omitempty"`
	IsManagement *null.Bool     `json:"isManagement,omitempty"`
	OrgUID       *uuid.NullUUID `json:"orgUID,omitempty"`
	DepartmentID *null.Int64    `json:"departmentID,omitempty"`
	Permissions  []string       `json:"permissions,omitempty"`
	IsArchived   *null.Bool     `json:"isArchived,omitempty"`
}

type UpdateUser struct {
	FirstName *null.String   `json:"firstName,omitempty"`
	LastName  *null.String   `json:"lastName,omitempty"`
	Email     *null.String   `json:"email,omitempty"`
	Phone     *null.String   `json:"phone,omitempty"`
	OrgUID    *uuid.NullUUID `json:"orgUID,omitempty"`
	RoleID    *null.Int64    `json:"roleID,omitempty"`
}

type UserActivitiesResult struct {
	UserActivities []dbmodels.UserActivity `json:"userActivities"`
	Total          int                     `json:"total"`
}

type UserResult struct {
	Users []dbmodels.User `json:"users"`
	Total int             `json:"total"`
}

type Action string

const (
	ActionArchive   Action = "Archive"
	ActionUnarchive Action = "Unarchive"
)

var AllAction = []Action{
	ActionArchive,
	ActionUnarchive,
}

func (e Action) IsValid() bool {
	switch e {
	case ActionArchive, ActionUnarchive:
		return true
	}
	return false
}

func (e Action) String() string {
	return string(e)
}

func (e *Action) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Action(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Action", str)
	}
	return nil
}

func (e Action) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FilterOption string

const (
	FilterOptionAll      FilterOption = "All"
	FilterOptionActive   FilterOption = "Active"
	FilterOptionDraft    FilterOption = "Draft"
	FilterOptionAccepted FilterOption = "Accepted"
	FilterOptionArchived FilterOption = "Archived"
)

var AllFilterOption = []FilterOption{
	FilterOptionAll,
	FilterOptionActive,
	FilterOptionDraft,
	FilterOptionAccepted,
	FilterOptionArchived,
}

func (e FilterOption) IsValid() bool {
	switch e {
	case FilterOptionAll, FilterOptionActive, FilterOptionDraft, FilterOptionAccepted, FilterOptionArchived:
		return true
	}
	return false
}

func (e FilterOption) String() string {
	return string(e)
}

func (e *FilterOption) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilterOption(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilterOption", str)
	}
	return nil
}

func (e FilterOption) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortByOption string

const (
	SortByOptionDateCreated  SortByOption = "DateCreated"
	SortByOptionDateUpdated  SortByOption = "DateUpdated"
	SortByOptionAlphabetical SortByOption = "Alphabetical"
)

var AllSortByOption = []SortByOption{
	SortByOptionDateCreated,
	SortByOptionDateUpdated,
	SortByOptionAlphabetical,
}

func (e SortByOption) IsValid() bool {
	switch e {
	case SortByOptionDateCreated, SortByOptionDateUpdated, SortByOptionAlphabetical:
		return true
	}
	return false
}

func (e SortByOption) String() string {
	return string(e)
}

func (e *SortByOption) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortByOption(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortByOption", str)
	}
	return nil
}

func (e SortByOption) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortDir string

const (
	SortDirAscending  SortDir = "Ascending"
	SortDirDescending SortDir = "Descending"
)

var AllSortDir = []SortDir{
	SortDirAscending,
	SortDirDescending,
}

func (e SortDir) IsValid() bool {
	switch e {
	case SortDirAscending, SortDirDescending:
		return true
	}
	return false
}

func (e SortDir) String() string {
	return string(e)
}

func (e *SortDir) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDir(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDir", str)
	}
	return nil
}

func (e SortDir) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
